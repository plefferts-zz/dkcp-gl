{"version":3,"sources":["webpack:///geodesic/bundle.js","webpack:///./examples/geodesic/index.js"],"names":["webpackJsonp","module","exports","__webpack_require__","getRenderable","Renderable","before","getUniforms","camera","computeMatrix","factory","maxColors","colorAllocation","Allocation","Float","shader","Shader","attributes","position","color","varyings","f_color","vertex_uniforms","m","Model","Geodesics","this","subdivisions","addAttribute","i","item","vertices","add","uniforms","colors","buffer","DkcpGl","shaders","geodesic","main","canvas","document","getElementById","frameRate","element","wasd","delta","theta","Math","PI","screen","red","id","yellow","green","cyan","blue","magenta","white","geos","addRenderable","g","getGeometry","color_ints","points","length","push","random","forEach","point","allocations","tris","beginFrameRendering"],"mappings":"AAAAA,cAAc,IAER,SAASC,EAAQC,EAASC,GCuBhC,QAAAC,KACA,UAAAC,IACAC,OAAA,aAEAC,YAAA,WACA,OACAC,SAAAC,kBAGAC,QAAA,WAEA,GAAAC,GAAA,GACAC,EAAA,GAAAC,GAAAC,MAAAH,EAAA,GAEAI,EAAA,GAAAC,GAAA,WACA,iFAEO,WACP,sCAEAD,GAAAE,WAAAC,SAAA,OACAH,EAAAE,WAAAE,MAAA,QACAJ,EAAAK,SAAAC,QAAA,OACAN,EAAAO,gBAAAd,OAAA,OACAO,EAAAO,gBAAA,UAAAX,EAAA,WAEA,IAAAY,GAAA,GAAAC,GAAAC,UAAAC,KAAAX,EAAA,EAAAY,EAeA,OAdAJ,GAAAK,aAAA,qCAAAC,EAAAC,GACA,MAAAA,GAAAC,SAAAF,KAGAN,EAAAK,aAAA,kCAAAC,EAAAC,GACA,OACAlB,EAAAoB,IAAAF,EAAAX,MAAAU,GAAAC,EAAA,WACA,MAAAA,GAAAX,MAAAU,GAAAV,WAKAI,EAAAU,SAAAC,OAAAtB,EAAAuB,OAEAZ,KAlEA,GAAAa,GAAAjC,EAAA,GAEAE,EAAA+B,EAAA/B,WACAmB,EAAAY,EAAAZ,MAEAR,GADAoB,EAAAC,QACAD,EAAApB,QACAH,EAAAuB,EAAAvB,WACAyB,EAAAF,EAAAE,SAEAC,EAAA,GAAAH,IACAI,OAAAC,SAAAC,eAAA,UACAC,WACAC,QAAAH,SAAAC,eAAA,cAEAG,MACAJ,kBACAK,MAAA,GACAC,OAAAC,KAAAC,GAAA,MAGAzC,EAAA+B,EAAA/B,OACA0C,EAAAX,EAAAW,OAEAvB,EAAA,GAgDAwB,GAAeC,GAAA,MAAAjC,OAAA,UACfkC,GAAeD,GAAA,SAAAjC,OAAA,UACfmC,GAAeF,GAAA,QAAAjC,OAAA,UACfoC,GAAeH,GAAA,OAAAjC,OAAA,UACfqC,GAAeJ,GAAA,OAAAjC,OAAA,UACfsC,GAAeL,GAAA,UAAAjC,OAAA,UACfuC,GAAeN,GAAA,QAAAjC,OAAA,UAEfe,GAAAiB,EAAAE,EAAAC,EAAAC,EAAAC,EAAAC,EAAAC,GAGAC,EAAAvD,GACA8C,GAAAU,cAAAD,EAIA,QAFAE,GAAAvB,EAAAX,GAAAmC,cACAC,KACAlC,EAAA,EAAeA,EAAAgC,EAAAG,OAAAC,OAAqBpC,IACpCkC,EAAAG,KAAAhC,EAAAc,KAAAmB,SAAAjC,EAAA+B,OAAA,GAEA,IAAAlC,KACA8B,GAAAG,OAAAI,QAAA,SAAAC,GACAtC,EAAAmC,MACAG,EAAA,GACAA,EAAA,GACAA,EAAA,KACA,MAGAV,EAAA3B,KACAb,MAAA4C,EACAO,eACAC,KAAAV,EAAAU,KACAxC,YAKA,QAFA8B,GAAAvB,EAAAX,GAAAmC,cACAC,KACAlC,EAAA,EAAeA,EAAAgC,EAAAG,OAAAC,OAAqBpC,IACpCkC,EAAAG,KAAAhC,EAAAc,KAAAmB,SAAAjC,EAAA+B,OAAA,GAEA,IAAAlC,KACA8B,GAAAG,OAAAI,QAAA,SAAAC,GACAtC,EAAAmC,MACAG,EAAA,OACAA,EAAA,OACAA,EAAA,QACA,MAGAV,EAAA3B,KACAb,MAAA4C,EACAO,eACAC,KAAAV,EAAAU,KACAxC,aAGAmB,EAAAsB,qBAAA","file":"geodesic/bundle.js","sourcesContent":["webpackJsonp([3],[\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar DkcpGl            = __webpack_require__(1)\n\t\n\tvar Renderable        = DkcpGl.Renderable\n\tvar Model             = DkcpGl.Model\n\tvar shaders           = DkcpGl.shaders\n\tvar Shader            = DkcpGl.Shader\n\tvar Allocation        = DkcpGl.Allocation\n\tvar geodesic          = DkcpGl.geodesic\n\t\n\tvar main = new DkcpGl({\n\t  canvas : document.getElementById('canvas'),\n\t  frameRate : {\n\t    element : document.getElementById('framerate')\n\t  },\n\t  wasd : {\n\t    document : document,\n\t    delta : .5,\n\t    theta : -Math.PI / 30\n\t  }\n\t})\n\tvar camera = main.camera;\n\tvar screen = main.screen;\n\t\n\tvar subdivisions = 11;\n\t\n\tfunction getRenderable() {\n\t  return new Renderable({\n\t    before : function () {\n\t    },\n\t    getUniforms : function () {\n\t      return {\n\t        camera : camera.computeMatrix()\n\t      }\n\t    },\n\t    factory : function () {\n\t      \n\t      var maxColors = 10\n\t      var colorAllocation = new Allocation.Float(maxColors, 4)\n\t      \n\t      var shader = new Shader(function () {\n\t        return '  gl_Position = camera * position; \\n' + \n\t               '  f_color = colors[int(color)]; \\n'\n\t      }, function () {\n\t        return '  gl_FragColor = f_color ;\\n'\n\t      })\n\t      shader.attributes.position   = 'vec4';\n\t      shader.attributes.color      = 'float';\n\t      shader.varyings.f_color      = 'vec4';\n\t      shader.vertex_uniforms.camera = 'mat4';\n\t      shader.vertex_uniforms['colors[' + maxColors + ']'] = 'vec4';\n\t\n\t      var m = new Model.Geodesics(this, shader, 2, subdivisions)\n\t      m.addAttribute('position', 4, 'Float32Array', function (i, item) {\n\t        return item.vertices[i]\n\t      });\n\t      \n\t      m.addAttribute('color', 1, 'Float32Array', function (i, item) {\n\t        return [\n\t          colorAllocation.add(item.color[i], item, function () {\n\t            return item.color[i].color\n\t          })\n\t        ]\n\t      });\n\t  \n\t      m.uniforms.colors = colorAllocation.buffer;\n\t  \n\t      return m\n\t    }\n\t  })\n\t}\n\t\n\tvar red     = {id: 'red',     color: [1, 0, 0, 1]}\n\tvar yellow  = {id: 'yellow',  color: [1, 1, 0, 1]}\n\tvar green   = {id: 'green',   color: [0, 1, 0, 1]}\n\tvar cyan    = {id: 'cyan',    color: [0, 1, 1, 1]}\n\tvar blue    = {id: 'blue',    color: [0, 0, 1, 1]}\n\tvar magenta = {id: 'magenta', color: [1, 0, 1, 1]}\n\tvar white   = {id: 'white',   color: [1, 1, 1, 1]}\n\t\n\tvar colors  = [red, yellow, green, cyan, blue, magenta, white];\n\t\n\t  \n\tvar geos  = getRenderable()\n\tscreen.addRenderable(geos)\n\t\n\tvar g = geodesic(subdivisions).getGeometry();\n\tvar color_ints = [];\n\tfor (var i = 0; i < g.points.length; i ++) {\n\t  color_ints.push(colors[Math.random() * colors.length | 0])\n\t}\n\tvar vertices = []\n\tg.points.forEach(function (point) {\n\t  vertices.push([\n\t    point[0],\n\t    point[1],\n\t    point[2] + 5,\n\t    1\n\t  ])\n\t})\n\tgeos.add({\n\t  color       : color_ints,\n\t  allocations : {},\n\t  tris        : g.tris,\n\t  vertices    : vertices\n\t})\n\t\n\tvar g = geodesic(subdivisions).getGeometry();\n\tvar color_ints = [];\n\tfor (var i = 0; i < g.points.length; i ++) {\n\t  color_ints.push(colors[Math.random() * colors.length | 0])\n\t}\n\tvar vertices = []\n\tg.points.forEach(function (point) {\n\t  vertices.push([\n\t    point[0] / 3 + 4,\n\t    point[1] / 3 + 4,\n\t    point[2] / 3 + 10,\n\t    1\n\t  ])\n\t})\n\tgeos.add({\n\t  color       : color_ints,\n\t  allocations : {},\n\t  tris        : g.tris,\n\t  vertices    : vertices\n\t})\n\t\n\tscreen.beginFrameRendering(false)\n\n\n/***/ }\n]);\n\n\n/** WEBPACK FOOTER **\n ** geodesic/bundle.js\n **/","var DkcpGl            = require('../../src/dkcp-gl')\n\nvar Renderable        = DkcpGl.Renderable\nvar Model             = DkcpGl.Model\nvar shaders           = DkcpGl.shaders\nvar Shader            = DkcpGl.Shader\nvar Allocation        = DkcpGl.Allocation\nvar geodesic          = DkcpGl.geodesic\n\nvar main = new DkcpGl({\n  canvas : document.getElementById('canvas'),\n  frameRate : {\n    element : document.getElementById('framerate')\n  },\n  wasd : {\n    document : document,\n    delta : .5,\n    theta : -Math.PI / 30\n  }\n})\nvar camera = main.camera;\nvar screen = main.screen;\n\nvar subdivisions = 11;\n\nfunction getRenderable() {\n  return new Renderable({\n    before : function () {\n    },\n    getUniforms : function () {\n      return {\n        camera : camera.computeMatrix()\n      }\n    },\n    factory : function () {\n      \n      var maxColors = 10\n      var colorAllocation = new Allocation.Float(maxColors, 4)\n      \n      var shader = new Shader(function () {\n        return '  gl_Position = camera * position; \\n' + \n               '  f_color = colors[int(color)]; \\n'\n      }, function () {\n        return '  gl_FragColor = f_color ;\\n'\n      })\n      shader.attributes.position   = 'vec4';\n      shader.attributes.color      = 'float';\n      shader.varyings.f_color      = 'vec4';\n      shader.vertex_uniforms.camera = 'mat4';\n      shader.vertex_uniforms['colors[' + maxColors + ']'] = 'vec4';\n\n      var m = new Model.Geodesics(this, shader, 2, subdivisions)\n      m.addAttribute('position', 4, 'Float32Array', function (i, item) {\n        return item.vertices[i]\n      });\n      \n      m.addAttribute('color', 1, 'Float32Array', function (i, item) {\n        return [\n          colorAllocation.add(item.color[i], item, function () {\n            return item.color[i].color\n          })\n        ]\n      });\n  \n      m.uniforms.colors = colorAllocation.buffer;\n  \n      return m\n    }\n  })\n}\n\nvar red     = {id: 'red',     color: [1, 0, 0, 1]}\nvar yellow  = {id: 'yellow',  color: [1, 1, 0, 1]}\nvar green   = {id: 'green',   color: [0, 1, 0, 1]}\nvar cyan    = {id: 'cyan',    color: [0, 1, 1, 1]}\nvar blue    = {id: 'blue',    color: [0, 0, 1, 1]}\nvar magenta = {id: 'magenta', color: [1, 0, 1, 1]}\nvar white   = {id: 'white',   color: [1, 1, 1, 1]}\n\nvar colors  = [red, yellow, green, cyan, blue, magenta, white];\n\n  \nvar geos  = getRenderable()\nscreen.addRenderable(geos)\n\nvar g = geodesic(subdivisions).getGeometry();\nvar color_ints = [];\nfor (var i = 0; i < g.points.length; i ++) {\n  color_ints.push(colors[Math.random() * colors.length | 0])\n}\nvar vertices = []\ng.points.forEach(function (point) {\n  vertices.push([\n    point[0],\n    point[1],\n    point[2] + 5,\n    1\n  ])\n})\ngeos.add({\n  color       : color_ints,\n  allocations : {},\n  tris        : g.tris,\n  vertices    : vertices\n})\n\nvar g = geodesic(subdivisions).getGeometry();\nvar color_ints = [];\nfor (var i = 0; i < g.points.length; i ++) {\n  color_ints.push(colors[Math.random() * colors.length | 0])\n}\nvar vertices = []\ng.points.forEach(function (point) {\n  vertices.push([\n    point[0] / 3 + 4,\n    point[1] / 3 + 4,\n    point[2] / 3 + 10,\n    1\n  ])\n})\ngeos.add({\n  color       : color_ints,\n  allocations : {},\n  tris        : g.tris,\n  vertices    : vertices\n})\n\nscreen.beginFrameRendering(false)\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./examples/geodesic/index.js\n ** module id = 0\n ** module chunks = 3\n **/"],"sourceRoot":""}